#! perl
# TabbedEx plugin for rxvt-unicode; based on original tabbed plugin.
# https://github.com/mina86/urxvt-tabbedex
# Copyright 2006-2020 tabbed and tabbedex authors
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 NAME

tabbedex - tabbed interface to urxvt; extended

=head1 DESCRIPTION

This extension implements a tabbed terminal.  Once rxvt-unicode starts, slave
terminals can be started in their own tabs and switched between.  At each point
only one terminal is visible.  rxvt-unicode exits once all tabs are closed.

Once at least two tabs are created a tab bar is displayed at the top of the
window which lists all the slave terminals.  Clicking on a number/name of a tab
on that bar switches to it.

tabbedex is an extended version of the tabbed plugin distributed with urxvt.

=head2 Key bindings

Creating new tabs, switching between them and moving them around can be
performed through the following key bindings:

=over

=item B<Shift-Down>

Creates a new tab.

=item B<Shift-Left> and B<Shift-Right>

Switches to the tab on the left or on the right of the current tab.  Movement
wraps around once at the first or last tab.

=item B<Meta-F1> through B<Meta-F12>

Switches to the first through twelfth tab.

=item B<Control-Left> and B<Control-right>

Move current tab to the left or right.  Wraps around on the first and last
position.

=item B<Shift-Up>

Allows current tab to be renamed.  Tab bar is shown if it was hidden, current
tab's name (if any) is cleared and cursor is displayed in its place.  Typing
text renames the tab, backspace or Ctrl+H delete the last character, Escape or
Ctrl+C aborts the rename operation and Enter accepts the new name.

=back

Default key bindings can be disabled using B<no-tabbedex-keys> resource (see
below) and replaced with custom ones using urxvt's B<keysym> resource.

=head1 CONFIGURATION

The extension can be configured with X resources just like urxvt itself, for
example:

    URxvt.tabbedex.tabbar-fg: 4
    URxvt.tabbedex.tabbar-bg: 0

Tabbedex recognises the following resources:

=over

=item B<autohide>: I<boolean>

If set (the default), the tab bar will be hidden unless there are at least two
tabs open.  This is irrespective of whether C<NEW> button or tab's title is
displayed.

=item B<new-button>: I<boolean>

If set, a C<NEW> button will be displayed on the left of the tab bar.  Clicking
the button creates a new tab.  It is not displayed by default.

=item B<title>: I<boolean>

If set (the default), when tab bar is visible and there is enough space left,
current tab's title will be displayed after the last tab.

=item B<tabbar-fg>:   [I<style>] I<colour>  and  B<tabbar-bg>:   I<colour>

=item B<tab-fg>:      [I<style>] I<colour>  and  B<tab-bg>:      I<colour>

=item B<bell-fg>:     [I<style>] I<colour>  and  B<bell-bg>:     I<colour>

=item B<bell-tab-fg>: [I<style>] I<colour>  and  B<bell-tab-bg>: I<colour>

=item B<title-fg>:    [I<style>] I<colour>  and  B<title-bg>:    I<colour>

Foreground and background styles of elements of the tab bar, respectively: 1)
the tab bar including background tabs, 2) the current tab and new button, 3)
a background tab on which bell has rung, 4) the current tab if bell has rung and
5) tab title.

Colours can be specified as: I<-2> meaning default foreground, I<-1> meaning
default background, an integer between B<0> and B<255> specifying index in
terminal' colour palette or any other string which X11 recognises as a colour
(e.g. B<#1155CC>).

Furthermore, the B<-fg> resource can be prefixed by combination of B<bold>,
B<italic>, B<blink>, B<reverse-video> and B<underline> which specify the
font-style of the text.

The default values for the settings are as follows:

    Component | *-fg          | *-bg | Description
    ----------+---------------+------+----------------------
    tabbar    |             3 |    0 | brown text on black
    tab       | bold        0 |    1 | black text on red
    bell      |      italic 0 |    3 | black text on brown
    bell-tab  | bold italic 5 |    4 | magenta text on blue
    title     |      italic 2 |    0 | green text on black

=item B<bell-timeout>: I<number>

Time in seconds, one second by default, a bell is said to be ringing on current
tab for after it was rung.  Setting this to zero essentially disables the
B<bell-tab-(fg|bg)> styling of tabs.

=item B<tab-arguments>: I<string>

Arguments passed when starting a slave tabs.  If not specified, I<-e B<command>>
switch used when starting urxvt command is used (if any).  If specified, the
value is first expanded (see below), then split into words using shell quoting
rules and those are passed as arguments to slave terminals when they are
started.

This resource can be used to pass any arguments however doing so may have
unintended consequences.  Options such as I<-bw> or I<-geometry> are especially
problematic but others may cause issues as well.  Because of this, only I<-e
B>command arguments>> is officially supported.

The value is expanded by replacing two-character sequences starting with
a percent sign as follows:

=over

=item I<%%>

Replaced by a literal percent sign.

=item I<%e>

Replaced by properly quoted I<-e B<command>> arguments if they were given when
urxvt was started or an empty string otherwise.  See also I<%E> which may be
easier for some uses.

Remember that if neither I<%e> nor I<%E> is used, I<-e> switch passed when
starting urxvt will be completely ignored.

=item I<%E>

Similar to I<%e> but I<-e> is not included in the expansion and if I<%e> would
expand to an empty string I<%E> expands to value of SHELL environment variable
or I</bin/sh> if that's empty.  This means that I<%E> is always a valid command.

For example, here's how the sequence can be used to set TABBEDEX_NUM environment
variables when running a command:

    URxvt.tabbedex.tab-arguments: \
        -e /usr/bin/env TABBEDEX_NUM=%n %E

=item I<%n>

Replaced by the total number of tabs opened during the lifetime of the
extension.  Not to be confused with number of tabs currently open.  The counter
starts at zero and always increments for each subsequent tab.

=item I<%p>

Replaced by ID of a process group which is running in foreground of the pseudo
terminal in the current tab (as in, not the new tab being created but the tab
where the new tab request originated from) or -1 if this piece of information
could not be determined.

This can be used to guess the current working directory of current tab.

=item I<%~>

Replaced by a properly quoted value of HOME environment variable or I</> if it's
not set.

=back

Unrecognised sequences are replaced with an empty string.

See B<command-runner.sample> file distributed with this extension for some ideas
how this resource can be used to start different commands in different tabs or
how to start new tabs in the same working directory as the current tab is using.

=item B<no-tabbedex-keys>: I<boolean>

If set, the default key bindings (described at the beginning of this document)
are not set up.  The mappings can be recreated using urxvt's B<keysym.*>
resources:

    URxvt.tabbedex.no-tabbedex-keys: yes
    URxvt.keysym.Shift-Left:    tabbedex:prev_tab
    URxvt.keysym.Shift-Right:   tabbedex:next_tab
    URxvt.keysym.Shift-Down:    tabbedex:new_tab
    URxvt.keysym.Shift-Up:      tabbedex:rename_tab
    URxvt.keysym.Control-Left:  tabbedex:move_tab_left
    URxvt.keysym.Control-Right: tabbedex:move_tab_right
    URxvt.keysym.Meta-F1:       tabbedex:goto_tab_1
    URxvt.keysym.Meta-F2:       tabbedex:goto_tab_2
    URxvt.keysym.Meta-F3:       tabbedex:goto_tab_3
    URxvt.keysym.Meta-F4:       tabbedex:goto_tab_4
    URxvt.keysym.Meta-F5:       tabbedex:goto_tab_5
    URxvt.keysym.Meta-F6:       tabbedex:goto_tab_6
    URxvt.keysym.Meta-F7:       tabbedex:goto_tab_7
    URxvt.keysym.Meta-F8:       tabbedex:goto_tab_8
    URxvt.keysym.Meta-F9:       tabbedex:goto_tab_9
    URxvt.keysym.Meta-F10:      tabbedex:goto_tab_10
    URxvt.keysym.Meta-F11:      tabbedex:goto_tab_11
    URxvt.keysym.Meta-F12:      tabbedex:goto_tab_12

See I<ACTIONS AND USER COMMANDS> below for list of available actions.

=item B<perl-ext-blacklist>: I<string>

A comma-separated list of extensions that must not be loaded into the slave
terminals (tabs).  tabbedex plugin is implicitly added onto the list.

=item B<reopen-on-close>: I<boolean>

If set, whenever last tab is destroyed a new one will be created.

=item B<tabbar-timeouts>: I<string>

When new text is written to a background tab, activity marks are displayed
around its number (or name if it has one) on the tab bar.  By default Unicode
characters are used to display a block which grows with time the longer it was
since last time there was any activity in the tab.

This resource allows for this to be customised.  It's format is

    ( <timeout> ":" <char> <char>? ":" )* <timeout> ":" <char> <char>? ":"

where <timeout> is timeout in seconds and <char> is an activity character.  If
two characters are given, they specify left and right activity marks.  If one
character is given, it specifies both.  For example:

    URxvt.tabbedex.tabbar-timeouts: 0:|:3:():6:[]:9:{}:12:<>

See B<tabbedex;ignore_line_activity> OSC sequence below to see how the activity
detection can be further affected.

=item B<tabbed.tabbedex-rs-prefix>: I<string>

A B<deprecated> alternative resource name prefix.  It's always specified with
C<tabbed> prefix.

If resource using extension's name as well as one using the alternate prefix are
found, the former takes precedence.  If only the latter is present, its value is
used but a warning is issued as well, for example:

    URxvt.tabbed.tabbedex-rs-prefix: tabbed
    URxvt.tabbedex.tabbar-fg: 4   -- used
    URxvt.tabbed.tabbar-fg:   5   -- ignored
    URxvt.tabbed.tabbar-bg:   0   -- used but issues a warning

For best backwards compatibility, all options should use C<tabbedex> prefix and
the <tabbedex-rs-prefix> resource should be set to percent sign as in:

    URxvt.tabbed.tabbedex-rs-prefix: %

=back

Extension's behaviour is also influenced by some of URxvt's configuration
options as well.  (See I<RESOURCES> in the L<urxvt(1)> manpage for more
information about them).  The options include:

=over

=item B<mapAlert>

If set, when bell rings in a background tab, the tab is selected as current.

=item B<urgentOnBell>

If set, when bell rings in a background tab, the master terminal's urgency hint
is set.

=back

=head1 ACTIONS AND USER COMMANDS

tabbedex supports actions which can be bound to keystrokes using
B<URxvt.keysym>.I<keysym> resource.  For example:

    URxvt.keysym.Control-t:            tabbedex:new_tab
    URxvt.keysym.Control-Tab:          tabbedex:next_tab
    URxvt.keysym.Control-Shift-Tab:    tabbedex:prev_tab
    ! Shift-Tab is often bound to ISO_Left_Tab in X keyboard
    ! layouts.  In those layouts Control-Shift-Tab won't
    ! work and Control-ISO_Left_Tab is needed instead:
    URxvt.keysym.Control-ISO_Left_Tab: tabbedex:prev_tab

makes I<Ctrl+T> create a new tab and I<Ctrl+Tab> and I<Ctrl+Shift+Tab> switch
between existing tabs.  Using the name of the extension as the prefix of the
keysym binding is preferred but when running an ancient urxvt (i.e. anything
prior to 9.21) an alternative B<perl:tabbedex> must be used instead.

Supported actions are:

=over

=item B<tabbedex:new_tab> and B<tabbedex:new_tab:>I<arguments>

Creates a new tab, puts it at the end of the tab list and switches to it.  In
the second form, I<arguments> temporarily override value of the B<tab-arguments>
resource.  This makes it possible to create bindings which start particular
commands, for example:

    URxvt.keysym.F1:    tabbedex:new_tab:-e info

makes it such that pressing F1 will open a new tab running B<info> command.
(Remember that I<arguments> are passed as arguments to urxvt so to run a command
B<-e> is required as in example above).

=item B<tabbedex:new_tab_>I<side>B<_this> and B<tabbedex:new_tab_>I<side>B<_this:>I<arguments>

Like B<tabbedex:new_tab> but puts the new tab before (if I<side> is B<before>)
or after (if I<side> is B<after>) the current tab on the tab list.  For example,

    URxvt.keysym.C-t:   tabbedex:new_tab_after_this

makes I<Ctrl+T> start a new tab next to the current one.

=item B<tabbedex:next_tab> and B<tabbedex:prev_tab>

Switches to the tab on the right or left of the current tab.  Wraps around when
switching right from the last tab or left from the first one.

=item B<tabbedex:next_tab:nowrap> and B<tabbedex:prev_tab:nowrap>

Switches tabs like B<tabbedex:next_tab> and B<tabbedex:prev_tab> action but does
not wrap around.  I.e. does nothing if trying to switch to the last tab’s next
tab or first tab’s previous tab.

=item B<tabbedex:move_tab_left> and B<tabbedex:move_tab_right>

Moves the current tab left or right.  Wraps around when moving last tab right or
first tab left.

=item B<tabbedex:move_tab_left:nowrap> and B<tabbedex:move_tab_right:nowrap>

Moves the current tab left or right like B<tabbedex:move_tab_left> and
B<tabbedex:move_tab_right> but does not wrap around.  I.e. moving first tab left
or last tab right does nothing.

=item B<tabbedex:goto_tab_>I<N>

If I<N> is a positive integer, switches to the I<N>th tab.  If I<N> is negative,
switches to the -I<N>th tab counting from the last one.

=item B<tabbedex:kill_tab>

Kills/destroys current tab.

=item B<tabbedex:rename_tab>

Start renaming the tab.

=back

=head1 OSC SEQUENCES

tabbedex supports a single OSC sequence which can be invoked by programs running
in the terminal by writing a special sequence, namely I<ESC ] 777 ; string ST>
where I<string> is the command to execute.  For example:

    printf '\033]777;tabbedex;set_tab_name;%s\007' "foo"

=over

=item B<tabbedex;set_tab_name;>I<name>

Sets name of the current tab to I<name>.

=item B<tabbedex;ignore_line_activity;>I<n>

Prevents new text on given line affecting activity marks displayed in the tab
bar (see B<tabbar-timeouts> resource).  Positive values specify I<n>th row from
the top, negative specify -I<n>th row from the bottom and zero disables the
filtering (thus making all updates affect activity marks).

This is useful if an application has a periodically-updating status line whose
refresh does not indicate activity in the tab.  For example, L<screen(1)> can
display current time in its hardstatus.  To prevent updates to the clock
registering as activity in the screen window, tabbedex can be instructed to
ignore the bottom row of the display:

    printf '\033]777;tabbedex;ignore_line_activity;%d\007' -1

To make this automatic a custom script for starting L<screen(1)> could be used:

    #!/bin/sh
    ignore_line_activity() {
        printf '\033]777;tabbedex;ignore_line_activity;%d\007' "$1"
    }
    ignore_line_activity -1
    screen "$@"
    ignore_line_activity 0

Note that if text wraps multiple lines, only the topmost row counts as changed.

=back

=head1 SEE ALSO

L<urxvt(1)>, L<urxvt-tabbed(1)>, L<tabbedex-command-runner(1)> and
L<tabbedex-pgid-cd(1)>

=head1 COPYRIGHT

Copyright 2006-2020 tabbed and tabbedex authors

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 AUTHOR

tabbedex has been created (as a fork of L<urxvt-tabbed(1)>) and is maintained by
Michal Nazarewicz.  For list of authors see B<AUTHORS> file distributed with the
extension.  Send bug reports and comments to mina86@mina86.com or file them at
L<https://github.com/mina86/urxvt-tabbedex>.

=cut

use Scalar::Util;
use Text::ParseWords;


# An initialisation hook which is called in root/master and slave tabs.  It’s
# purpose is to determine which one the object is and call that type’s
# initialisation code.
#
# The reason we do it this way rather than directly pointing urxvt at correct
# package is that we want urxvt to think that master and slave tabs both use
# ‘tabbedex’ extension.  Previously, the code would point tabs to
# a ‘urxvt::ext::tabbedex::tab’ extension but that resulted in terminal thinking
# the extension is ‘tabbedex::tab’ (actually it was even more complicated than
# that) and actions weren’t dispatched correctly.
#
# Now, no matter if it’s root or not, from urxvt’s point of view it’s all
# ‘tebbedex’ plugin.
sub on_init {
	my ($self) = @_;

	# If we are root tab, then terminal’s 'tabbedex-root-tab' property is
	# not set.  Otherwise it is set and it points to the root tab.
	my $root = delete $self->{term}{'tabbedex-root-tab'};
	my $type = 'root';
	if (defined $root) {
		$type = 'tab';
		$self->{root} = $root;
	}

	# Copy ISA so things behave the same way.
	my $pkg = Scalar::Util::blessed($self);
	@{"urxvt::ext::tabbedex::$type\::ISA"} = @{"$pkg\::ISA"};

	# Change type of the object so methods in proper package are used.
	bless $self, "urxvt::ext::tabbedex::$type";

	# And continue initialisation.
	my $supports_action = enable_action_hooks($self, !defined $root);
	$self->enable_hooks;
	$self->init;
	if ($root->{register_keysyms}) {
		register_keysyms($self, $supports_action);
	}

	()
}

sub register_keysyms {
	my ($self, $supports_action) = @_;
	my $prefix = ($supports_action && $self->{_name}) || 'perl:tabbedex';
	$self->parse_keysym('Shift-Left', $prefix . ':prev_tab');
	$self->parse_keysym('Shift-Right', $prefix . ':next_tab');
	$self->parse_keysym('Shift-Down', $prefix . ':new_tab');
	$self->parse_keysym('Shift-Up', $prefix . ':rename_tab');
	$self->parse_keysym('Control-Left', $prefix . ':move_tab_left');
	$self->parse_keysym('Control-Right', $prefix . ':move_tab_right');
	for my $num (1..12) {
		$self->parse_keysym('Meta-F' . $num,
				    $prefix . ':goto_tab_' . $num);
	}
}

# Install handlers for ‘action’ and ‘user_command’ hooks.  This subroutine means
# that root and tab packages should not touch those hooks themselves.  This is
# here mostly because ancient urxvt errors out when trying to define ‘action’
# hook.  As I didn’t want to duplicate handling of that, I moved it here where
# both packages are handled.  And since ‘user_command’ is closely related, why
# not handle it here as well?  A µoptimisation is that whatever way an action
# reaches the plugin, there’s just one hop till ‘tab_action’ is called.
sub enable_action_hooks {
	my ($self, $isroot) = @_;
	$self->enable(user_command => $isroot ? sub {
		if ($_[1] =~ s/^tabbedex://) {
			splice @_, 1, 0, $_[0]{cur};
			goto \&urxvt::ext::tabbedex::root::tab_action;
		}
	} : sub {
		if ($_[1] =~ s/^tabbedex://) {
			unshift @_, $_[0]{root};
			goto \&urxvt::ext::tabbedex::root::tab_action;
		}
	});
	# Guard against ancient urxvts which do not support ‘action’ hook.  We
	# probably shouldn’t bother, but oh well…
	eval {
		$self->enable(action => $isroot ? sub {
			splice @_, 1, 0, $_[0]{cur};
			goto \&urxvt::ext::tabbedex::root::tab_action;
		} : sub {
			unshift @_, $_[0]{root};
			goto \&urxvt::ext::tabbedex::root::tab_action;
		});
		1
	} // 0
}


package urxvt::ext::tabbedex::root;

use Encode qw(decode);

{
	my %hooks;

	sub _on($&) {
		my ($hook, $sub) = @_;
		$hooks{$hook} = $sub
	}

	sub enable_hooks {
		my ($root) = @_;
		$root->enable(%hooks);
	}
}


sub warn {
	my $root = shift;
	urxvt::warn(join '', $root->{_name} // 'tabbedex', ': ', @_, "\n");
}


sub tab_activity_marks {
	my ($root, $tab, $now) = @_;
	if (!defined($tab->{last_activity})) {
		return (' ', ' ');
	}
	my $diff = $now - $tab->{last_activity};
	my $prev;
	for my $spec (@{ $root->{timeouts} }) {
		my ($time, $left, $right) = @$spec;
		if ($diff >= $time) {
			my $next = defined $prev ? $prev - $diff : undef;
			return ($left, $right, $next);
		}
		$prev = $time;
	}
	('!', '!')  # we should never be here
}


# Returns a ($first_idx, $last_idx) list indicating index of first and last
# (inclusive) tab to be shown in the tabbar.
sub _tabbar_range {
	my ($root, $ncol, $new_button, $names, $first_idx) = @_;
	my $last_idx = $first_idx;

	my $max = int(($ncol - 1) / 3) - 3;
	$max = $max < 2 ? 1 : $max;
	my $width = length $names->[$first_idx];
	$ncol -= (($width < $max ? $width : $max) + 2 +  # name and marks
	          ($first_idx > 0 && !$new_button) +  # left arrow
	          ($last_idx < $#$names));  # right arrow

	my $try_add = sub {
		my $idx = shift;
		if ($idx >= 0 && $idx <= $#$names) {
			my $length = length $names->[$idx];
			my $n = $ncol - (($length < $max ? $length : $max) + 2);
			$n -= ($idx > 0) && ($idx < $#$names);
			if ($n > 0) {
				$ncol = $n;
				return 1;
			}
		}
		0
	};

	if ($try_add->($last_idx + 1)) {
		++$last_idx;
	}
	while ($try_add->($first_idx - 1)) {
		--$first_idx;
	}
	while ($try_add->($last_idx + 1)) {
		++$last_idx;
	}

	($first_idx, $last_idx)
}

# Truncates names of the tabs so that all tabs visible in the tabbar (specified
# by the [$first_idx..$last_idx] range) can all fit.  Tries to keep as much of
# the names of all tabs as possible.
sub _tabbar_truncate_names {
	my ($root, $ncol, $new_button, $names, $first_idx, $last_idx) = @_;

	$ncol -= (3 * ($last_idx - $first_idx) + 2 +  # pipes and marks
	          ($first_idx > 0 && !$new_button) +  # left arrow
	          ($last_idx < $#$names));  # right arrow
	my $max = int($ncol / ($last_idx - $first_idx + 1));
	my $cur_max = $max;

	if ($max > 0 && $first_idx < $last_idx) {
		my @lengths = sort { $b <=> $a }
		              grep { $_ <= $max ? (($ncol -= $_), 0) : 1 }
		              map  length, @{ $names }[$first_idx .. $last_idx];
		while (@lengths &&
		       $lengths[$#lengths] <= ($max = int($ncol / @lengths))) {
			do {
				$ncol -= pop @lengths;
			} while (@lengths && $lengths[$#lengths] <= $max);
		}
		$cur_max = $max + $ncol - $max * @lengths;
	}

	for my $idx ($first_idx .. $last_idx) {
		my $width = $root->{cur} == $root->{tabs}[$idx]
			? $cur_max : $max;
		if (length(my $name = $names->[$idx]) <= $width) {
			# nop
		} elsif ($width >= 2) {
			$names->[$idx] = '…' . substr $name, -($width - 1);
		} elsif ($width >= 1) {
			$names->[$idx] = substr $name, -1;
		} else {  # extremely narrow window
			$names->[$idx] = '';
		}
	}
}

# Determines layout of the tabbar.  Returns a ($new_button, $first_idx,
# $last_idx, \@names) list where:
# - $new_button specifies text of the NEW button or is an empty string,
# - $first_idx is an index of the first visible tab,
# - $last_idx is an index of the last visible tab and
# - \@names is an array of (possibly truncated) names of the tabs.
sub _tabbar_layout {
	my ($root) = @_;

	my $ncol = $root->ncol;
	my $new_button = '';
	if ($root->{new_button}) {
		if ($ncol >= 60) {
			$new_button = '[NEW]';
		} elsif ($ncol >= 30) {
			$new_button = 'NEW';
		} elsif ($ncol >= 13) {
			$new_button = '+';
		}
	}
	$ncol -= !!$new_button + length $new_button;

	my $max = int(($ncol - 1) / 3) - 3;
	$max = $max < 2 ? 1 : $max;
	my ($total_truncated, $total_full, $cur_idx) = (-1, -1);
	my @names = map {
		my $tab = $root->{tabs}[$_];
		if ($tab == $root->{cur}) {
			$cur_idx = $_;
		}
		my $name      = $tab->{name} || '' . ($_ + 1);
		my $length    = length $name;
		$total_full      += 3 + $length;
		$total_truncated += 3 + ($length < $max ? $length : $max);
		$name
	} 0..$#{ $root->{tabs} };

	my ($first_idx, $last_idx) = (0, $#names);
	if ($ncol < $total_full) {
		if ($ncol < $total_truncated) {
			($first_idx, $last_idx) = $root->_tabbar_range(
				$ncol, !!$new_button, \@names, $cur_idx);
		}
		$root->_tabbar_truncate_names(
			$ncol, !!$new_button, \@names, $first_idx, $last_idx);
	}

	($new_button, $first_idx, $last_idx, \@names)
}

sub min {
	@_ = grep { defined && $_ > 0 } @_;
	my $best = shift;
	for my $n (@_) {
		if ($n < $best) {
			$best = $n;
		}
	}
	$best;
}

sub refresh {
	my ($root, $now) = @_;

	my $visible = (!$root->{autohide} ||
	               @{ $root->{tabs} } > 1 ||
	               $root->{cur}->is_being_renamed);
	if ($visible != !!$root->{tabheight}) {
		$root->{tabheight} = $visible * $root->{maxtabheight};
		$root->configure;
		$root->copy_properties;
	}
	if (!$visible) {
		return;
	}

	my ($new_button, $first_idx, $last_idx, $names) = $root->_tabbar_layout;
	my $bar = new urxvt::ext::tabbedex::tabbar($root);

	if ($new_button) {
		$bar->add_button($new_button, 1, -1);
	}
	if ($first_idx) {
		$bar->add_arrow(-1);
	}

	if (!defined $now) {
		$now = urxvt::NOW;
	}
	my $min_delay;
	for my $idx ($first_idx .. $last_idx) {
		my $tab = $root->{tabs}[$idx];
		my ($left, $right, $delay) =
			$root->tab_activity_marks($tab, $now);
		$bar->add_button(
			$left . $names->[$idx] . $right,
			($tab == $root->{cur}) + 2 * ($now < $tab->{bell_ends}),
			$idx);
		if ($tab->is_being_renamed) {
			$bar->put_cursor(-2);
		}
		$min_delay = min $min_delay, $delay, $tab->{bell_ends} - $now;
	}

	if ($last_idx < $#$names) {
		$bar->add_arrow(1);
	}

	if ($root->{tab_title} && $bar->space_left > 0) {
		my @str = $root->XGetWindowProperty(
			$root->parent, $root->{tab_title});
		if (@str && $str[2]) {
			my $str = decode('utf8', $str[2]);
			$bar->add_title($root->special_encode($str));
		}
	}

	$bar->apply;
	$root->want_refresh;
	if (defined $min_delay) {
		$root->{timer}->start($now + $min_delay);
	}
}

sub tab_term_init {
	my ($root, $term, $index) = @_;
	$term->{'tabbedex-root-tab'} = $root;
	$term->{'tabbedex-tab-index'} = $index;

	for (0 .. urxvt::NUM_RESOURCES - 1) {
		if (defined(my $value = $root->{resource}[$_])) {
			$term->resource("+$_" => $value);
		}
	}

	foreach my $key (values %urxvt::OPTION) {
		my $val = exists $root->{option}{$key}
		  ? $root->{option}{$key} : $root->option($key);
		$term->option($key, $val);
	}

	if (defined(my $blacklist = $root->{perl_ext_blacklist})) {
		$term->resource(perl_ext_2 =>
			$term->resource('perl_ext_2') . $blacklist);
	}
}

sub quote_words {
	join ' ', map {
		my $v = $_;
		$v =~ s/'/'\\''/g;
		"'$v'";
	} @_
}

sub args_percent_substitution {
	my ($root, $ch, $tab) = @_;
	if ($ch eq '%') {
		$ch
	} elsif ($ch eq 'e') {
		quote_words @{ $root->{argv} }
	} elsif ($ch eq 'E') {
		quote_words @{ $root->{argv} }
			? @{ $root->{argv} }[1..$#{ $root->{argv} }]
			: ($ENV{SHELL} || '/bin/sh')
	} elsif ($ch eq 'p') {
		$tab ? $tab->foreground_pgid : -1
	} elsif ($ch eq 'n') {
		$root->{total_tabs_open} // 0
	} elsif ($ch eq '~') {
		exists $ENV{'HOME'} ? quote_words $ENV{'HOME'} : '/'
	} else {
		$root->warn('unrecognised substitution in ‘tab-arguments’: ',
			    '‘%', $ch, '’; will substitute with empty string');
		''
	}
}

sub new_tab {
	my ($root, $tab, $args, $index) = @_;

	if (!defined $args) {
		$args = $root->{tab_arguments};
	}
	$args =~ s/^\s+|\s+$//g;
	if ($args eq '' || $args eq '%e') {
		$args = $root->{argv};
	} else {
		$args =~ s/%(.)/
			$root->args_percent_substitution($1, $tab)
		/ge;
		if (defined Text::ParseWords::shellwords($args)) {
			$args = [Text::ParseWords::shellwords($args)];
		} else {
			$root->warn('error parsing ‘tab-arguments’ value: ‘',
				    $args, '’; ignoring');
			$args = $root->{argv};
		}
	}

	push @urxvt::TERM_INIT, sub { $root->tab_term_init($_[0], $index) };
	push @urxvt::TERM_EXT, urxvt::ext::tabbedex::;
	new urxvt::term
		$root->env, $urxvt::RXVTNAME,
		-embed => $root->parent,
		@{ $args }
}


sub configure {
   my ($root) = @_;

   my $tab = $root->{cur};

   # this is an extremely dirty way to force a configurenotify, but who cares
   $tab->XMoveResizeWindow (
      $tab->parent,
      0, $root->{tabheight} + 1,
      $root->width, $root->height - $root->{tabheight}
   );
   $tab->XMoveResizeWindow (
      $tab->parent,
      0, $root->{tabheight},
      $root->width, $root->height - $root->{tabheight}
   );
}


sub copy_properties {
   my ($root) = @_;
   my $tab = $root->{cur};

   my $wm_normal_hints = $root->XInternAtom ("WM_NORMAL_HINTS");

   my $current = delete $root->{current_properties};

   # pass 1: copy over properties different or nonexisting
   for my $atom ($tab->XListProperties ($tab->parent)) {
      my ($type, $format, $items) = $root->XGetWindowProperty ($tab->parent,
                                                               $atom);

      # fix up size hints
      if ($atom == $wm_normal_hints && $root->{tabheight}) {
         # typedef struct {
         #         long flags;                  /* 0 */
         #         int x, y;                    /* 1, 2 */ /* Obsolete */
         #         int width, height;           /* 3, 4 */ /* Obsolete */
         #         int min_width, min_height;   /* 5, 6 */
         #         int max_width, max_height;   /* 7, 8 */
         #         int width_inc, height_inc;   /* 9, 10 */
         #         struct {
         #                 int x; /* numerator */
         #                 int y; /* denominator */
         #         } min_aspect, max_aspect;    /* 11, 12, 13, 14 */
         #         int base_width, base_height; /* 15, 16 */
         #         int win_gravity;             /* 17 */
         # } XSizeHints;
         #
         # (Don’t ask me how this works with long and int types.  Somehow it
         # does – mina86).
         my (@hints) = unpack "l!*", $items;
         $hints[$_] += $root->{tabheight} for (4, 6, 16);
         $items = pack "l!*", @hints;
      }

      my $cur = delete $current->{$atom};

      # update if changed, we assume empty items and zero type and
      # format will not happen
      $root->XChangeProperty ($root->parent, $atom, $type, $format, $items)
         if $cur->[0] != $type or $cur->[1] != $format or $cur->[2] ne $items;

      $root->{current_properties}{$atom} = [$type, $format, $items];
   }

   # pass 2, delete all extraneous properties
   $root->XDeleteProperty ($root->parent, $_) for keys %$current;
}


sub make_current {
	my ($root, $tab, $bell_ends) = @_;

	if (!ref $tab) {
		$tab = $root->{tabs}[$tab];
	}

	my $cur = $root->{cur};
	if ($cur == $tab) {
		return;
	}

	if ($cur) {
		if ($cur->is_being_renamed) {
			return;
		}
		$cur->enable_activity_hook(1);
		delete $cur->{last_activity};
		$cur->{bell_ends} = 0;
		$cur->XUnmapWindow ($cur->parent) if $cur->mapped;
		$cur->focus_out;
	}

	$root->{cur} = $tab;
	# Disable the add_lines hook so that we don’t waste time processing that
	# hook for the current tab.  We’re not interested in that hook on the
	# current tab.
	$tab->enable_activity_hook(0);

	$root->configure;
	$root->copy_properties;

	$tab->focus_out; # just in case, should be a nop
	$tab->focus_in if $root->focus;

	$tab->XMapWindow ($tab->parent);
	delete $tab->{last_activity};
	$tab->{bell_ends} = $bell_ends // 0;

	$root->refresh;
}


_on focus_in => sub {
   my ($root, $event) = @_;
   $root->{cur}->focus_in;
   ();
};

_on focus_out => sub {
   my ($root, $event) = @_;
   $root->{cur}->focus_out;
   ();
};

_on tt_write => sub {
    my ($root, $octets) = @_;
    $root->{cur}->tt_write ($octets);
    1
};

_on key_press => sub {
	my ($root, $event) = @_;

	# This check fixes dead keys when pointer is not above the terminal
	# window (see https://github.com/mina86/urxvt-tabbedex/issues/26).  The
	# fix only works if ibus is used; if ibus is not used, the condition is
	# always true.
	#
	# When a dead key is combined with a letter a key_press event with zero
	# state, keycode and time is generated.  If we forward it to the tab and
	# report back to urxvt that the event was handled, nothing happens and
	# the character is not inserted.
	#
	# On the other hand, if we ignore such events everything works as
	# expected.  To be honest, I don’t completely understand what is
	# happening here, but it fixes stuff. — mina86
	if ($event->{state} || $event->{keycode} || $event->{time}) {
		$root->key_event('key_press', $event);
	}
};

_on key_release => sub {
   my ($root, $event) = @_;
   $root->key_event('key_release', $event);
};

sub key_event {
	my ($root, $type, $event) = @_;

	my $tab = $root->{cur};
	$tab->$type($event->{state}, $event->{keycode}, $event->{time});

	# refresh_check is available since rxvt-unicode 9.22.  For some reason
	# $tab->can('refresh_check') doesn’t work which is why eval block is
	# used to silence warnings.
	eval {
		$tab->refresh_check;
	};
	if ($@ && $@ !~ /refresh_check/) {
		# If there was a warning unrelated to refresh_check propagate
		# it.  Otherwise ignore.
		warn "$@";
	}
	1;
}

_on button_release => sub {
	my ($root, $event) = @_;

	if ($root->{cur}->is_being_renamed || $event->{row} != 0 ||
	    $event->{button} != 1) {
		return ();
	}

	my $col = $event->{col};
	for my $button (@{ $root->{tabofs} }) {
		if ($col < $button->[0]) {
			last;
		} elsif ($col >= $button->[1]) {
			# nop
		} elsif ($button->[2] == -1) {
			$root->new_tab($root->{cur});
		} else {
			$root->make_current($button->[2]);
		}
	}
	1;
};


{

# TODO: Remove warning in late 2022.
my %matching_marks = ('[' => ']', '{' => '}', '(' => ')', '<' => '>');

my $matching_marks_warned = 0;

sub parse_single_timeout {
	my ($root, $t, $l, $r) = @_;
	if (!defined $r && defined($r = $matching_marks{$l})) {
		if (!$matching_marks_warned) {
			$matching_marks_warned = 1;
			$root->warn('automatic paren pairing in ',
				    '‘tabbar-timeouts’ is no longer supported');
		}
		$root->warn('‘', $l, '’ won’t be matched with ‘', $r, '’');
		undef $r;
	}
	$l = $root->special_encode($l);
	$r = defined $r ? $root->special_encode($r) : $l;
	[$t + 0, $l, $r]
}

sub parse_timeouts {
	my ($root, $timeouts) = @_;
	my $char = eval { qr/\X/ } // qr/./;
	my @timeouts;
	while ($timeouts =~ /\G(\d*\.\d+|\d+):($char)($char)?(?::|$)/g) {
		push @timeouts, $root->parse_single_timeout($1, $2, $3);
	}
	if ($matching_marks_warned) {
		$root->warn('specify characters pairs explicitly instead');
	}
	@timeouts = sort { $b->[0] <=> $a->[0] } @timeouts;
	if (!@timeouts || $timeouts[$#timeouts][0] > 0) {
		push @timeouts, [0, '*', '*'];
	}
	\@timeouts
}

}

sub init {
   my ($root) = @_;

   $root->{resource} = [map $root->resource ("+$_"),
                            0 .. urxvt::NUM_RESOURCES - 1];

   $root->{hpadding} = $root->{vpadding} = 2 * $root->int_bwidth;
   $root->resource (int_bwidth => 0);
   $root->resource (pty_fd => -1);

   if (defined(my $key = $urxvt::OPTION{scrollBar})) {
      if ($root->{option}{$key} = $root->option($key, 0)) {
         $root->{hpadding} += $root->get_scrollbar_thickness;
      }
   }
   # Disable ‘intensityStyles’ so that bold, blink etc. specified in tabbar
   # styles don’t affect the colours.
   if (defined(my $key = $urxvt::OPTION{intensityStyles})) {
      $root->{option}{$key} = $root->option($key, 0);
   }

   my $rs = new urxvt::ext::tabbedex::rs_reader($root);

   $root->{timeouts} = $root->parse_timeouts($rs->text(
      'tabbar-timeouts', '0:▁:3:▂:6:▃:9:▄:12:▅:15:▆:18:▇:21:█'));
   $root->{bell_timeout}     = $rs->text('bell-timeout', 1) + 0;
   $root->{new_button}       = $rs->bool('new-button', 0);
   $root->{tab_title}        = $rs->bool('title', 1);
   $root->{autohide}         = $rs->bool('autohide', 1);
   $root->{register_keysyms} = !$rs->bool('no-tabbedex-keys', 0);
   $root->{reopen_on_close}  = $rs->bool('reopen-on-close', 0);
   $root->{tab_arguments}    = $rs->text('tab-arguments', '');

   if (my $blacklist = $rs->text('perl-ext-blacklist')) {
       $blacklist =~ s/,/,-/;
       $root->{perl_ext_blacklist} = ',-' . $blacklist;
   }

   my ($colours, $cmd) = $rs->colours(['            3', '0', 'tabbar'],
                                      ['bold        0', '1', 'tab'],
                                      ['     italic 0', '3', 'bell'],
                                      ['bold italic 5', '4', 'bell-tab'],
                                      ['     italic 2', '0', 'title']);
   $root->{init_cmd} = $cmd . "\033[?25l";
   $root->{rs_colours} = $colours;

   $root->{timer} = urxvt::timer->new->cb ( sub { $root->refresh; } );
}

# Figures out the thickness of scroll bar.  This is based on scrollBar_t::setup
# code and written with the assumption that urxvt was compiled with all styles
# enabled.
sub get_scrollbar_thickness {
	my ($root) = @_;

	my $style = $root->resource('scrollstyle') || '';
	my $width;

	if ($style =~ /^next/i) {
		$style = 'next';
		$width = 19;  # SB_WIDTH_NEXT
	} elsif ($style =~ /^xterm/i) {
		$width = 15;  # SB_STYLE_XTERM
	} elsif ($style =~ /^plain/i) {
		$width = 7;  # SB_WIDTH_PLAIN
	} else {
		$style = 'rxvt';
		$width = 10;  # SB_WIDTH_RXVT
	}

	# Relevant excerpt from the C++ code:
	#
	#  thickness = term->rs[Rs_scrollBar_thickness];
	#  if (style != SB_STYLE_NEXT)	/* dishonour request - for now */
	#    if (thickness && (i = atoi (thickness)) >= SB_WIDTH_MINIMUM)
	#      width = min (i, SB_WIDTH_MAXIMUM);
	if ($style ne 'next') {
		my $thickness = $root->resource('scrollBar_thickness');
		if ($thickness && $thickness >= 5) {
			# SB_WIDTH_MAXIMUM == 100
			$width = $thickness < 100 ? $thickness : 100;
		}
	}

	my $key = $urxvt::OPTION{scrollBar_floating};
	if ($style eq 'rxvt' && defined $key && !$root->option($key)) {
		$width += 2;
	}

	$width
}

_on start => sub {
   my ($root) = @_;

   $root->{maxtabheight} =
      $root->int_bwidth + $root->fheight + $root->lineSpace;
   $root->{tabheight} = $root->{autohide} ? 0 : $root->{maxtabheight};

   # Root window is always created without scroll bar or border which means that
   # it’s sized without any space allocated for those elements.  However, tabs
   # may have those options enabled which makes means that they end up with less
   # usable space than user requested. To account for that, enlarge the root to
   # make space for the border and scroll bar.
   my $hpadding = delete $root->{hpadding};
   my $vpadding = delete $root->{vpadding};
   if ($hpadding || $vpadding || $root->{tabheight}) {
      my $w = $root->width + $hpadding;
      my $h = $root->height + $vpadding + $root->{tabheight};
      $root->XMoveResizeWindow($root->parent, 0, 0, $w, $h);
   }

   $root->cmd_parse(delete $root->{init_cmd});

   my @argv = $root->argv;
   do {
      shift @argv;
   } while @argv && $argv[0] ne "-e";
   $root->{argv} = \@argv;

   if ($root->{tab_title}) {
      $root->{tab_title} = $root->XInternAtom("_NET_WM_NAME", 1);
   }

   $root->new_tab;

   ();
};


_on configure_notify => sub {
   my ($root, $event) = @_;
   $root->configure;
   $root->refresh;
   ();
};


_on wm_delete_window => sub {
	my ($root) = @_;
	# Disable reopen-on-close so we respect delete window request.  If
	# reopen-on-close was to remain true, as soon as last tab was closed
	# a new would be created and we would never exit.
	$root->{reopen_on_close} = 0;
	$_->destroy for @{ $root->{tabs} };
	1;
};


sub tab_start {
	my ($root, $tab) = @_;
	my $index = delete $tab->{term}{'tabbedex-tab-index'};
	$tab->XChangeInput ($tab->parent, urxvt::PropertyChangeMask);
	if (defined $index && $index < @{ $root->{tabs} }) {
		splice @{ $root->{tabs} }, $index, 0, $tab;
	} else {
		push @{ $root->{tabs} }, $tab;
	}
	++$root->{total_tabs_open};
	$root->make_current($tab);
	();
}


sub tab_destroy {
	my ($root, $tab) = @_;

	my $idx = $tab->index;
	splice @{ $root->{tabs} }, $idx, 1;

	if (!@{ $root->{tabs} }) {
		if (!$root->{reopen_on_close}) {
			# Delay destruction a tiny bit.
			$root->{destroy} = urxvt::iw->new->start->cb(sub {
				$root->{timer}->stop;
				$root->destroy;
			});
			return ();
		}
		$root->new_tab;
	}

	if ($root->{cur} == $tab) {
		delete $root->{cur};
		$root->make_current($idx < @{ $root->{tabs} } ? $idx : -1);
	} else {
		$root->refresh;
	}

	();
}


sub tab_property_notify {
   my ($root, $tab, $event) = @_;

   $root->copy_properties
      if $event->{window} == $tab->parent;

   ();
}


sub tab_bell {
	my ($root, $tab, $event) = @_;
	my $now = urxvt::NOW;

	my $key = $urxvt::OPTION{urgentOnBell};
	if (defined($key) && $tab->option($key) && !$root->focus) {
		$root->set_urgency(1);
	}

	if ($tab == $root->{cur}) {
		$tab->{bell_ends} = $now + $root->{bell_timeout};
	} elsif (defined($key = $urxvt::OPTION{mapAlert}) &&
	         $tab->option($key)) {
		$root->make_current($tab, $now + $root->{bell_timeout});
		return;
	} else {
		$tab->{bell_ends} = ~0;
	}

	# refresh called to update rendering (if bell wasn’t active in the tab)
	# and update timer’s timeout.
	$root->refresh($now);

	();
}


sub tab_line_update {
	my ($root, $tab, $row) = @_;
	my $ignore = $tab->{ignore_line_activity} // 0;
	# 0 ≤ $row < nrow thus if $ignore is zero the condition is always true.
	# Otherwise, the two tests handle checks for when $ignore is positive
	# and negative respectively.
	if ($row + 1 != $ignore && $tab->nrow + $ignore != $row) {
		my $now = urxvt::NOW;
		my @pre = $root->tab_activity_marks($tab, $now);
		$tab->{last_activity} = $now;
		my @post = $root->tab_activity_marks($tab, $now);
		if ($pre[0] ne $post[0] || $pre[1] ne $post[1]) {
			$root->refresh($now);
		}
	}
	()
}


sub tab_action {
	my ($root, $tab, $cmd) = @_;
	if ($cmd =~ /^new_tab(?:_(before|after)_this)?(?::(.*))?$/) {
		if (!$root->{cur}->is_being_renamed) {
			my $index;
			if (defined $1) {
				$index = $tab->index + ($1 eq 'after');
			}
			$root->new_tab($tab, $2, $index);
		}
	} elsif ($cmd =~ /^(next|prev)_tab(:nowrap)?$/) {
		my $index = $tab->index + ($1 eq 'next' ? 1 : -1);
		if (!$2 || ($index >= 0 && $index < @{ $root->{tabs} })) {
			$root->make_current($index % @{ $root->{tabs} });
		}
	} elsif ($cmd =~ /^move_tab_(left|right)(:nowrap)?$/) {
		$root->move_tab($tab, $1 eq 'left' ? -1 : 1, !!$2);
	} elsif ($cmd =~ /^goto_tab[_:](-?)(0*[1-9]\d*)$/) {
		if ($2 <= @{ $root->{tabs} }) {
			$root->make_current($1 eq '' ? $2 - 1 : -$2);
		}
	} elsif ($cmd eq 'rename_tab') {
		if ($tab == $root->{cur} && $tab->start_rename_tab) {
			$root->refresh;
		}
	} elsif ($cmd eq 'kill_tab') {
		$tab->destroy;
	} else {
		$root->warn('unrecognised action: ‘', $cmd, '’; ignoring');
	}
	()
}

sub move_tab {
	my ($root, $tab, $direction, $nowrap) = @_;
	if (@{ $root->{tabs} } < 2) {
		return;
	}

	my $last = $#{$root->{tabs}};
	my $idx = $tab->index;

	if ($idx == 0 && $direction == -1) {
		if ($nowrap) {
			return;
		}
		push @{$root->{tabs}}, shift @{$root->{tabs}};
	} elsif ($idx == $last && $direction == 1) {
		if ($nowrap) {
			return;
		}
		unshift @{$root->{tabs}}, pop @{$root->{tabs}};
	} else {
		($root->{tabs}[$idx], $root->{tabs}[$idx + $direction]) =
			($root->{tabs}[$idx + $direction], $root->{tabs}[$idx]);
	}
	$root->refresh;
}


sub tab_osc_seq_perl {
	my ($root, $tab, $osc) = @_;

	# For historical reasons, we also accept misspelled "tabbedx" prefix.
	if ($osc =~ /^tabbede?x;set_tab_name;(.*)$/) {
		my $name = $root->locale_decode($1);
		if ($tab->set_name($root->special_encode($name))) {
			$root->refresh;
		}
		1;
	} elsif ($osc =~ /^tabbedex;ignore_line_activity;(-?\d+)$/) {
		$tab->{ignore_line_activity} = $1 + 0;
		1;
	}
}


package urxvt::ext::tabbedex::tab;

use POSIX qw/tcgetpgrp/;

# helper extension implementing the subwindows of a tabbed terminal.
# simply proxies all interesting calls back to the tabbedex class.


{
	my %hooks = map {
		my $name = "urxvt::ext::tabbedex::root::tab_$_";
		$_ => sub {
			unshift @_, $_[0]{root};
			goto &$name;
		}
	} qw(start destroy property_notify line_update bell osc_seq_perl);

	sub enable_hooks {
		my ($root) = @_;
		$root->enable(%hooks);
	}

	sub enable_activity_hook {
		my ($tab, $enable) = (@_, 1);
		if ($enable) {
			$tab->enable(line_update => $hooks{line_update});
		} else {
			$tab->disable('line_update');
		}
	}
}

sub init {
	$_[0]{bell_ends} = 0;
}


sub index {
	my ($tab) = @_;
	my $tabs = $tab->{root}{tabs};
	my $idx = 0;
	++$idx while $tabs->[$idx] != $tab;
	$idx;
}


sub foreground_pgid {
	my $n = $_[0]->pty_fd;
	$n < 0 || ($n = tcgetpgrp($n)) < 0 ? -1 : $n
}


sub start_rename_tab {
	my ($tab) = @_;
	if ($tab->is_being_renamed) {
		return 0;
	}
	$tab->{old_name} = $tab->{name};
	$tab->{name} = ' ';
	$tab->enable('key_press', \&_rename_tab_key_press);
	1
}

sub finish_rename_tab {
	my ($tab, $accept) = @_;
	if (!$tab->is_being_renamed) {
		$tab->{root}->warn('finish_rename_tab called on tab which is ',
				   'not being renamed; this is an internal ',
				   'error, please report it');
		return;
	}
	if ($accept) {
		substr $tab->{name}, -1, 1, '';
	} else {
		$tab->{name} = $tab->{old_name};
	}
	delete $tab->{old_name};
	$tab->disable('key_press');
}

sub set_name {
	my ($tab, $name) = @_;
	if ($tab->is_being_renamed) {
		$tab->{old_name} = $name;
		0
	} else {
		$tab->{name} = $name;
		1
	}
}

sub is_being_renamed { exists $_[0]{old_name} }

sub _is_escape($$) {
	my ($event, $keysym) = @_;
	return 1 if $keysym == 0xff1b;  # Escape
	return 0 unless $event->{state} & urxvt::ControlMask;
	$keysym == 99 || $keysym == 67;  # Ctrl+C
}

sub _is_backspace($$) {
	my ($event, $keysym) = @_;
	return 1 if $keysym == 0xff08;  # Backspace
	return 0 unless $event->{state} & urxvt::ControlMask;
	$keysym == 104 || $keysym == 72;  # Ctrl+H
}

sub _rename_tab_key_press {
	my ($tab, $event, $keysym, $octets) = @_;

	# rxvt-unicode-scroll-bug-fix.patch causes early key_press events to be
	# passed without $keysym or $octects arguments passed.  Work around it
	# by ignoring such invocations; we’ll be called again soon with all
	# those arguments.  The patch shouldn’t be used any more anyway.
	if (!defined $keysym) {
		return 0;
	}

	my $is_enter = $keysym == 0xff0d || $keysym == 0xff8d;
	if ($is_enter || _is_escape $event, $keysym) {
		$tab->finish_rename_tab($is_enter);
	} elsif (_is_backspace $event, $keysym) {
		substr $tab->{name}, -2, 1, '';
	} elsif ($octets !~ /[\x00-\x1f]/) {
		my $text = $tab->locale_decode($octets);
		substr $tab->{name}, -1, 0, $tab->special_encode($text);
	} else {
		return 1;
	}

	$tab->{root}->refresh;
	1
}


## Class for getting data from resources.  Most notably, it handles the
## deprecated ‘tabbedex-rs-prefix’ resource and parsing of colours.
package urxvt::ext::tabbedex::rs_reader;

sub new {
	my ($class, $root) = @_;
	# TODO: Stop respecting the $prefix in late 2022.
	my $prefix = $root->x_resource('tabbed.tabbedex-rs-prefix');
	my $extname = $root->{_name};
	my $rs = [$root, $extname];
	if (!defined $prefix || ($prefix ne '%' && $prefix ne $extname)) {
		push @$rs, $prefix;
	}
	bless $rs, $class
}

sub text {
	my ($rs, $name, $default) = @_;
	my ($root, $extname, $prefix) = @$rs;
	my $value = $root->x_resource("%.$name");
	if (defined $value) {
		# nop
	} elsif (defined $prefix) {
		$value = $root->x_resource("$prefix.$name");
		if (defined $value) {
			$root->warn("‘$prefix.$name’ resource uses " .
			            "deprecated prefix; use ‘$extname.$name’ " .
				    "instead");
		}
	} elsif (@$rs == 3) {
		# TODO: Remove this warning (and simply ignore) in late 2022.
		# tabbed.tabbedex-rs-prefix was not specified.  It’s default
		# value used to be ‘tabbed’ so see if user might rely on that
		# still being the case.
		if (defined $root->x_resource("tabbed.$name")) {
			$root->warn("ignoring ‘tabbed.$name’ resource; " .
			            "use ‘$extname.$name’ instead");
		}
	}
	defined $value ? $root->locale_decode($value) : $default
}

sub bool {
	my $value = $_[0]->text($_[1]);
	defined $value ? $value !~ /^(?:false|0|no|off)$/i : $_[2];
}

sub colours {
	my $rs = shift;

	my %styles = (
		bold            => urxvt::RS_Bold,
		italic          => urxvt::RS_Italic,
		blink           => urxvt::RS_Blink,
		'reverse-video' => urxvt::RS_RVid,
		underline       => urxvt::RS_Uline
	);
	my $styles = join '|', keys %styles;

	my (@suffix, @styles, %used) = ('-fg', '-bg');
	for my $c (@_) {
		my $style = urxvt::DEFAULT_RSTYLE;
		for my $i (0, 1) {
			my $value = $rs->text($c->[2] . $suffix[$i], $c->[$i]);
			$value =~ s/\s+/ /g;
			$value =~ s/^ | $//g;
			while ($i == 0 && $value =~ s/^($styles) //) {
				$style |= $styles{$1};
			}
			if ($value =~ /^[-#a-zA-Z0-9 ]/) {
				$c->[$i] = $value;
			}
			$used{$c->[$i]} = undef;
		}
		push @styles, $style;
	}

	my ($i, $cmd) = (0, '');
	for my $key (keys %used) {
		if ($key =~ /^-?\d+$/ && -2 <= $key && $key <= 255) {
			$used{$key} = $key + 2;
		} else {
			++$i while exists $used{$i};
			$cmd .= ';' . $i . ';' . $key;
			$used{$key} = $used{$i} = $i + 2;
		}
	}

	for $i (0..$#_) {
		my ($fg, $bg) = @{ $_[$i] };
		$styles[$i] = urxvt::SET_COLOR $styles[$i], $used{$fg}, $used{$bg};
	}

	(\@styles, $cmd ? "\e]4$cmd\a" : '')
}


## Class for building up the tabbar.
package urxvt::ext::tabbedex::tabbar;

sub new {
	my ($class, $root) = @_;
	$#{ $root->{tabofs} } = -1;
	bless {
		root => $root,
		text => '',
		rend => [],
		ncol => $root->ncol,
		buttons => $root->{tabofs},
		pipe_pending => 0,
		pad_colour => 0,
	}, $class;
}

sub _append {
	my ($bar, $text, $c) = @_;
	$bar->{text} .= $text;
	push @{$bar->{rend}}, ($bar->{root}{rs_colours}[$c]) x length $text;
}

sub _append_pending_pipe_maybe {
	my ($bar) = @_;
	if ($bar->{pipe_pending}) {
		$bar->_append('|');
		$bar->{pipe_pending} = 0;
	}
}

sub space_left {
	my ($bar) = @_;
	$bar->{ncol} - $bar->{pipe_pending} - length $bar->{text};
}

sub add_button {
	my ($bar, $text, $color_idx, $code) = @_;
	$bar->_append_pending_pipe_maybe;
	my $start = length $bar->{text};
	$bar->_append($text, $color_idx);
	push @{ $bar->{buttons} }, [$start, length $bar->{text}, $code];
	$bar->{pipe_pending} = 1;
}

sub add_title {
	my ($bar, $text) = @_;
	$bar->_append_pending_pipe_maybe;
	my $available = $bar->space_left;
	if (length $text < $available) {
		$text = ' ' . $text;
	} elsif (length $text > $available && $available > 1) {
		substr($text, $available - 1) = '…';
	}
	$bar->_append($text, 4);
	$bar->{pad_colour} = 4;
}

sub add_arrow {
	my ($bar, $direction) = @_;
	$bar->_append($direction < 0 ? '←' : '→');
	$bar->{pipe_pending} = 0;
}

sub put_cursor {
	my ($bar, $dx) = @_;
	$bar->{cursor} = length($bar->{text}) + $dx + 1;
}

sub apply {
	my ($bar) = @_;
	$bar->{pipe_pending} = 0;
	if ($bar->{ncol} > length $bar->{text}) {
		$bar->_append(' ' x ($bar->{ncol} - length $bar->{text}),
		              $bar->{pad_colour});
	} elsif ($bar->{ncol} < length $bar->{text}) {
		$bar->{text} = substr $bar->{text}, 0, $bar->{ncol};
		splice @{ $bar->{rend} }, $bar->{ncol};
	}
	my ($term, $cur) = ($bar->{root}{term}, $bar->{cursor});
	$term->cmd_parse(defined($cur) ? "\e[1;${cur}f\e[?25h" : "\e[?25l");
	$term->ROW_t(0, $bar->{text});
	$term->ROW_r(0, $bar->{rend});
}
